\chapter{State Of The Art}
\label{ch:stateoftheart}
Today the realm of computer graphics has changed dramatically to what it was ten years ago.
Whereas 10 years ago the only devices which supported 3D graphics were either desktop computers or custom-designed computer games consoles.

On June 2007, Apple release its iPhone to the world, which included a PowerVR MBX chip~\cite{web:powervrmbx}.
An API was developed to enable mobile developers to use OpenGL on mobile applications, where resources are limited.
The OpenGL ES 1.1 API was developed which enabled the fixed function OpenGL pipeline on mobile devices~\cite{web:opengles11}.
This then evolved into the OpenGL ES 2.0 API, which allowed for programmable shaders like desktop OpenGL~\cite{web:opengles20}.
OpenGL ES 2.0 is supported by the new PowerVR SGX chip and is in current state of the art devices such as the Nokia N900 and the Apple iPhone 4~\cite{web:powervrsgx}.
This increase in power is due to an increased demand on users for games and other graphical applications on mobile devices.

As well as mobile devices gaining increased power and popularity, a similar movement is taking place at the same time in the web domain.
HTML, the markup language used for the web, is undergoing a significant review with HTML5~\cite{web:html5}.
HTML5 is an open standard for web applications which aims to replace existing plugins such as Adobe's flash which offer similar functionality.
One of the areas where flash is immensely popular is the world of online games.
This is shown by websites such as Kongregate, which have around 42,000 people playing their games at the time of writing~\cite{web:kongregate}.
Sites such as html5games~\cite{web:html5games} aims to capture this market using HTML5 as the technology.

HTML5 does not define a standard for 3D graphics, although a standard known as WebGL has been developed to fill this gap.

\section{WebGL}
WebGL is a 3D rendering API designed for the web.
WebGL is base on OpenGL ES 2.0 and offers similar functionality.
WebGL acts as a rendering context for the HTML5 canvas element~\cite{web:html5canvas}, which supports programmatic rendering in web pages using different rendering APIs.
An existing 2D rendering context also exists known as CanvasRenderingContext2D, which provides the ability to draw in 2D on web pages.

WebGL enables a new generation of web games which are 3D, rather than 2D as current web games are.
Tech demos for WebGL show advanced effects such as bump-mapping~\cite{web:webglbumpmapping} and real-time water effects~\cite{web:webglwater}.
WebGL offers the easy delivery of applications, with no need for the user explicitly download their application to use it.

WebGL provides a set of flexible primitives which should be applicable in any use case.
The idea is that APIs will be developed on top of WebGL to provide support for specific areas.
Indeed a list of frameworks built on top of WebGL is available on the Khronos wiki~\cite{web:webglframeworks}.

However WebGL has problems which are inherent in its design.
Since it is web based, assets need to be transported over the network.
For large assets, this could take a long time.
With this in mind, we consider procedural content generation and how this might be used to alleviate the problem.

\subsection{WebGL Frameworks}
There are a variety of web frameworks to choose from nowadays.
This section will discuss a few of them and their merits for use with WebGL.

\paragraph{Javascript}
Javascript is the main language used by web browsers and is built into all modern browsers.
Javascript includes dynamic typing, objects, run-time evaluation.
Functions are first-class objects in javascript, and it is possible to have nested functions.
It uses prototype-based inheritance however, which most programmers would not be familiar with.

For use with webgl, the advantage is that javascript is the default language for interacting with webgl.
There are also numerous frameworks written in javascript to ease the use of webgl~\cite{web:threejs}\cite{web:copperlicht}. 

There are many quirks in javascript which some programmers abuse and according to Crockford~\cite{web:javascriptbadparts}
It's lack of strong typing and the leniancy of some web browsers on some javascript errors can make it difficult to troublshoot issues.

Javascript was not chosen because we needed a language that would suit for both desktop and web applications, which javascript is not suited for.

\paragraph{Coffee-script}
Coffee-script~\cite{web:coffeescript} is a language which compiles directly to javascript.
It includes classical inheritance as well as comprehensions and other features which improve upon javascript.
The output javascript passes jslint~\cite{web:jslint}, a javascript code-quality tool.

It also allows the user to use webgl natively and since it compiles to javascript, all of the existing javascript frameworks can easily be used.

However the syntax is very specific to javascript and the code cannot be reused outside of the web, which was essential for parts of thie project.

\paragraph{Processing.js}
Processing.js~\cite{web:processingjs} is a framework for executing programs written in the Processing~\cite{web:processing} language in the web browser.
Processing is a java-like language for executing small programs known as ``sketches''.
The advantage to processing is that it enables quick demos to be programmed, as a lot of the details of drawing are abstracted away from the programmer.
It has support for WebGL however it does not give the programmer control over the lower-level details of optimisation which may be needed to get maximum performance from this project.

\paragraph{Gwt}
Gwt~\cite{web:gwt} is a framework for creating web applications in the Java programming language~\cite{web:java}.
The Java code is compiled to javascript as with Coffee-script.
The advantage to using java is that it is statically typed, is well-known and there are many existing tools to use with it.
It also allows for modern compilation tools such as Apache Maven~\cite{web:maven} to be used because of the maven gwt plugin~\cite{web:mvngwtplugin}.
This allows the codebase to be used with many different IDEs and development environments.
It also allows for the easy deployment of the code to web servers using Apache Tomcat~\cite{web:tomcat}, which is very straightforward as maven can deploy straight to tomcat using the ``tomcat:deploy'' target~\cite{web:mvntomcatplugin}.

It is difficult to use javascript libraries with Gwt, requiring the writing of a jsni wrapper~\cite{web:jsni} to communicate back and forth.

There are modules for use with webgl with Gwt.
The most mature of which is gwtgl~\cite{web:gwtgl}.

GwtGL was chosen for this project because of the use of java principally which the author was already familiar with and which is also used with processing, which was used for the design aspects of this project.

\section{WebGL Raw Performance}
At the beginning of the project, it was not known whether WebGL was a bottleneck or not.
I wanted to figure out how many triangles WebGL could handle before the framerate dropped to levels which were too low.
The test I divised was to present a single quad on the screen, subdivided into smaller quads, based on the subdivision level.
This concept is illustrated in Figure~\ref{fig:webgl_perf}.

This test involved deploying the code locally on a machine with the following specifications:
\begin{itemize}
	\item Gwt version: Gwt 2.3.0
	\item GwtGL version: GwtGL 0.9-SNAPSHOT
	\item Web Browser: Chromium 15.0.849.0 (Developer Build 0 Linux)
	\item Web Server: Apache Tomcat/5.5.33
	\item OS: Linux 3.0-ARCH x86\_64
	\item GPU: Palit Nvidia GeForce GTS 250 1024MB GDDR3 PCI-Express Graphics Card
	\item CPU: Intel Core i7 920 D0 Stepping (SLBEJ) 2.66Ghz (Nehalem)
	\item Mem: Corsair XMS3 4GB (2x2GB) DDR3 PC3-10666C9 1333MHz Triple Channel
	\item HDD: Seagate Barracuda 7200.12 500GB SATA-II 16MB Cache
\end{itemize}

The graph of how the framerate is affected by the number of polygons on the screen is shown in Figure~\ref{fig:webgl_perf_graph}.
The numbers shown are the averages of hundreds of samples for each scene.
As can be seen even with 6000000 polygons on the screen at once, the framerate stays about 40 frames per second.
I was unable to test any more due to the polygon size being too great to be loaded in by the javascript in a small enough time.
However this proved to me that the bottleneck would not be WebGL itself, but the javascript code which loads assets.

\begin{figure}
  \centering
  \subcaptionbox{Level 1 subdivision}{\includegraphics[width=0.5\textwidth]{images/webgl_perf0}}
  \subcaptionbox{Level 2 subdivision}{\includegraphics[width=0.5\textwidth]{images/webgl_perf1}} 
  \caption{Illustrating how the subdivision of the quad performance test works}
  \label{fig:webgl_perf}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=0.6\textwidth]{images/webgl_perf_graph}
  \caption{WebGL Framerate as the number of polygons on the screen at once increases}
  \label{fig:webgl_perf_graph}
\end{figure}


\section{Procedural Content Generation (PCG)}
\label{sec:pcg}
The generation of procedural content is important for many real-time applications. 
As we will see in this section it has been used to generate vast cities in real-time, the interiors of buildings and graphics effects on standard hardware.
Procedural Content Generation has the potential to 

\subsection{City Generation}
Recently, there has been much interest in the procedural generation of cities.
Ma\"{i}m et al.~\cite{maim2007populating} demonstrated how it is possible to recreate the population of historic cities using procedural techniques.
The use of procedural techniques to generate the crowds in Pompeii allowed realtime simulation with great variety in character representation.
This would not have been possible with traditional techniques.

The Metropolis project~\cite{web:metropolis} investigates the simulation of crowds in a modern city context.
Members of the crowd are modelled based on a variation of some template.
Different clothes are applied to the same templates to give the illusion of variation in the character models~\cite{mcdonnell2007pipeline}.
People are represented as agents which react to their environment~\cite{ulicny2002towards}.
In this way crowds are simulated using a variety of procedural techniques.

\begin{figure}
  \centering
    \includegraphics[width=0.7\textwidth]{images/metropolis}
  \caption{Screenshot of the Metropolis program in action}
\end{figure}

CityEngine~\cite{parish2001procedural} is an example of how procedural techniques can be applied to generates environments of great depth.
Using a combination of extended L-systems and self-sensitive L-systems, roads are generated which realistic simulate that of a target city.
Plans of buildings are generated between road segments in a recursive subdivision scheme, which discards inaccessible buildings.
The models of buildings are generated using an L-system using the bounding box of the building as the axiom of the L-system.
A technique known as \emph{layered grids} is proposed for the procedural generation of interesting textures for buildings.

\begin{figure}
  \centering
    \includegraphics[width=0.7\textwidth]{images/cityengine}
  \caption{Above: Street plan generated by CityEngine. Below: Actual plan of central manhattan.}
\end{figure}


Wonka et. al present a method for automatically modelling architecture~\cite{wonka2003instant} which generates a wide range of architectural features.
A new type of design grammar known as a ``Split grammars'' is used to derive building designs.
This allows the restriction of types of allowed rules. 
These restrictions make the grammars powerful enough for the modelling of buildings.
A parameter matching system allows the user to specify multiple high-level design goals so that the output appears consistent.
Control grammars are introduced which are simple context free grammars which handle spatial ideas in an orderly way which corresponds to architectural principles.
This paper's method gives a useful insight into how architectural features may be used to further enhance the generation of buildings in a procedural way.


\subsection{Building Interiors}
CityEngine provides a method for generating the exteriors of buildings, however this project will focus on the generation of indoor environments using procedural techniques.
Greuter et al. provide methods for generating\cite{greuter2003real} floor plans of buildings in a procedural fashion.
Plans are generated by merging various polygonal shapes in a pseudo-random fashion to generate a final plan of a series of floors.
These floor plans are extruded into the 3rd axes and the outdoor buildings models are created from this.
The floors are not populated with rooms however as the indoor environments are not meant to be seen.

So et al. use wall extrusion for generating 3D indoor environments from floor plans~\cite{so1998reconstruction}.
These generated indoor environments contain rooms.
So et al. apply the technique to a CAD tool, but the technique could easily be applied to an OpenGL-based environment also.

Hahn et al present a novel approach to the generation of virtual building interiors in real-time~\cite{hahn2006persistent}.
The approach uses a lazy generation scheme which is advantageous as it means that the amount of memory used is small. 
They divide the interiors of buildings into temporary regions and built regions.
Built regions contain the final visible product of the generator and hold the geometry needed for collision detection and rendering.
Temporary regions are placeholder regions which are turned into built regions in a lazy fashion.
Temporary regions are populated when the player enters them, via a portal system.
The generation of built regions is split into stages to simplify the implementation:

\begin{enumerate}
	\item Building Setup : Anything which effects multiple floors is generated at this stage. Elevators and stairs are included as well as global textures.
	\item Floor Division : Divides the building into evenly spaced floors. Floors are then divided into 2 parts.
	\item Hallway Division : Hallways are constructed by dividing the regions around other blocks which can be rectangular loops or straight segments of hallway. 
	\item Room Cluster Division : Regions between hallways are divided into rooms. 
	\item Built Region Generation : The geometry of the room is created and it is populated with objects. This is only done if the room contains a portal.
\end{enumerate}

The oldest generated built regions are periodically deleted to control memory. 
Newly generated built regions are put into a LRU cache so that they can be easily recalled if the player moves back into the region.

\subsection{Demoscene}
The demoscene is a community of computer programmers who specialise in making impressive visual and audio effects.
There is usually an emphasis on small code size such as the 4K competitions which has the restriction on a code size of 4KB~\cite{web:demoscene4k}.
These restricted sized demos are usually referred to as Intros.

Many demoscene programmers have applied their expertise to game-related applications.
One notable example is .theprodukkt~\cite{web:theprodukkt}, who developed the .kkrieger application~\cite{web:kkrieger}.
.kkrieger displays graphics of a level comparable to Doom3 in an executable which is 96K in size.
A comparison of .kkrieger with Doom 3 can be seen in \ref{fig:kkriegerdoomcomp}.
It achieves the results seen using a variety of procedural techniques, many of which will be applicable for this project.
An example is the procedural generation of textures.
It is unfortunant however that Demoscene programmers rarely release the code that they use to produce the effects shown.
This is the case with .kkrieger also.

\begin{figure}
  \centering
  \subcaptionbox{.kkrieger}{\includegraphics[width=0.5\textwidth]{images/kkrieger}}                
  \subcaptionbox{Doom 3}{\includegraphics[width=0.5\textwidth]{images/doom3}}                
  \caption{Comparison screenshots of Doom 3 and kkrieger}
  \label{fig:kkriegerdoomcomp}
\end{figure}

